{
  // Helper functions for creating AST nodes
  function createQuantifier(type, term, formula, identifier, unicode) {
    return { type: "Quantifier", quantifierType: type, variable: term, formula: formula, fixity: "prefix", identifier: identifier, unicode: unicode, precedence: 0 };
  }

  function createLogicalUnary(formula, fixity, identifier, unicode, precedence) {
    return { type: "LogicalUnary", formula: formula, fixity: fixity, identifier: identifier, unicode: unicode, precedence: precedence };
  }

  function createLogicalBinary(left, right, fixity, identifier, unicode, precedence, associativity) {
    return { type: "LogicalBinary", left: left, right: right, fixity: fixity, identifier: identifier, unicode: unicode, precedence: precedence, associativity: associativity };
  }

  function createApplication(term, count, terms, fixity) {
    return { type: "Application", symbol: term, arguments: terms.slice(0, count), fixity: fixity, precedence: 0, predicate: false };
  }

  function createVariable(name) {
    return { type: "Variable", name: name, precedence: 0 };
  }

  function createTuple(count, terms) {
    return { type: "Tuple", elements: terms.slice(0, count), precedence: 0 };
  }
}

Start
  = _ formula:Formula _ { return formula; }

// Lexical rules
_
  = [ \t]*

EOL
  = '\n' / '\r' / '\r\n'

Variable
  = [A-Za-z] [a-zA-Z0-9]* { return createVariable(text()); }

QuantifierOp
  = "\\forall" { return text(); }
  / "\\exists" { return text(); }

NEG = "\\neg" { return text(); }
WEDGE = "\\wedge" { return text(); }
VEE = "\\vee" { return text(); }
IMPLIES = "\\implies" { return text(); }
IFF = "\\iff" { return text(); }
FORALL = "\\forall" { return text(); }
EXISTS = "\\exists" { return text(); }
EQUALS = '=' { return createVariable(text()); }
OPEN = '('
CLOSE = ')'
COMMA = ','
LBRACE = '{'
RBRACE = '}'

// Main rules
Formula
  = Quantifier
  / IffFormula
  / Predicate

Quantifier
  = op:QuantifierOp _ v:Variable _ f:SimpleFormula {
      return createQuantifier(op === "\\forall" ? "UNIVERSAL" : "EXISTENTIAL", v, f, op, op === "\\forall" ? "∀" : "∃");
  }

IffFormula
  = l:ImpliesFormula _ IFF _ r:IffFormula {
      return createLogicalBinary(l, r, "infix", "\\iff", "↔", 4, "none");
  }
  / ImpliesFormula

ImpliesFormula
  = l:AndFormula _ IMPLIES _ r:ImpliesFormula {
      return createLogicalBinary(l, r, "infix", "\\implies", "→", 4, "right");
  }
  / AndFormula

AndFormula
  = l:OrFormula tail:(_ WEDGE _ r:OrFormula)* {
      return tail.reduce((result, element) => {
        return createLogicalBinary(result, element[3], "infix", "\\wedge", "∧", 3, "left");
      }, l);
    }

OrFormula
  = l:SimpleFormula tail:(_ VEE _ r:SimpleFormula)* {
      return tail.reduce((result, element) => {
        return createLogicalBinary(result, element[3], "infix", "\\vee", "∨", 3, "left");
      }, l);
    }

EqualPredicate
  = t1:Term _ i:EQUALS _ t2:Term {
      return createApplication(i, 2, [t1, t2], "infix");
  }

Predicate
  = f:Application

Negation
  = NEG _ f:SimpleFormula {
      return createLogicalUnary(f, "prefix", "\\neg", "¬", 0);
  }

SimpleFormula
  = Quantifier
  / EqualPredicate
  / Predicate
  / Negation
  / OPEN _ f:Formula _ CLOSE { return f; }

Term
  = Application
  / Variable
  / Tuple

Application
  = i:Variable _ OPEN _ args:TermList _ CLOSE {
      return createApplication(i, args.length, args, "functional");
  }

TermList
  = head:Term tail:(_ COMMA _ Term)* {
      return [head].concat(tail.map(e => e[3]));
  }

Tuple
  = OPEN _ args:TermList _ CLOSE {
      return createTuple(args.length, args);
  }
