{
  // Helper functions for creating AST nodes
  function createQuantifier(type, term, formula, identifier, unicode) {
    return { type: "Quantifier", quantifierType: type, variable: term, formula: formula, fixity: "prefix", identifier: identifier, unicode: unicode, precedence: 0 };
  }

  function createUnary(type, formula, fixity, identifier, unicode, precedence) {
    return { type: type, formula: formula, fixity: fixity, identifier: identifier, unicode: unicode, precedence: precedence };
  }

  function createBinaryConnective(connective, left, right, fixity, identifier, unicode, precedence, associativity) {
    return { type: "BinaryConnective", connective: connective, left: left, right: right, fixity: fixity, identifier: identifier, unicode: unicode, precedence: precedence, associativity: associativity };
  }

  function createPredicate(identifier, count, terms, unicode) {
    return { type: "Predicate", identifier: identifier, arguments: terms.slice(0, count), fixity: "functional", unicode: unicode, precedence: 0 };
  }

  function createFunction(term, count, terms, unicode) {
    return { type: "Function", functionName: term, arguments: terms.slice(0, count), fixity: "functional", identifier: term, unicode: unicode, precedence: 0 };
  }

  function createVariable(name) {
    return { type: "Variable", name: name, precedence: 0 };
  }

  function createSet(count, terms) {
    return { type: "Set", elements: terms.slice(0, count), precedence: 0 };
  }

  function createTuple(count, terms) {
    return { type: "Tuple", elements: terms.slice(0, count), precedence: 0 };
  }
}

Start
  = _ formula:Formula _ { return formula; }

// Lexical rules
_
  = [ \t]*

EOL
  = '\n' / '\r' / '\r\n'

Identifier
  = [A-Z] [a-zA-Z0-9]* { return text(); }

Variable
  = [a-z] [0-9]* { return createVariable(text()); }

QuantifierOp
  = "\\forall" { return text(); }
  / "\\exists" { return text(); }

NEG = "\\neg" { return text(); }
WEDGE = "\\wedge" { return text(); }
VEE = "\\vee" { return text(); }
IMPLIES = "\\implies" { return text(); }
IFF = "\\iff" { return text(); }
FORALL = "\\forall" { return text(); }
EXISTS = "\\exists" { return text(); }
EQUALS = '=' { return text(); }
OPEN = '('
CLOSE = ')'
COMMA = ','
LBRACE = '{'
RBRACE = '}'

// Main rules
Formula
  = Quantifier
  / IffFormula
  / Predicate

Quantifier
  = op:QuantifierOp _ v:Variable _ f:SimpleFormula {
      return createQuantifier(op === "\\forall" ? "UNIVERSAL" : "EXISTENTIAL", v, f, op, op === "\\forall" ? "∀" : "∃");
  }

IffFormula
  = l:ImpliesFormula _ IFF _ r:IffFormula {
      return createBinaryConnective("IFF", l, r, "infix", "\\iff", "↔", 1, "none");
  }
  / ImpliesFormula

ImpliesFormula
  = l:AndFormula _ IMPLIES _ r:ImpliesFormula {
      return createBinaryConnective("IMPLICATION", l, r, "infix", "\\implies", "→", 2, "right");
  }
  / AndFormula

AndFormula
  = l:OrFormula tail:(_ WEDGE _ r:OrFormula)* {
      return tail.reduce((result, element) => {
        return createBinaryConnective("CONJUNCTION", result, element[3], "infix", "\\wedge", "∧", 3, "left");
      }, l);
    }

OrFormula
  = l:SimpleFormula tail:(_ VEE _ r:SimpleFormula)* {
      return tail.reduce((result, element) => {
        return createBinaryConnective("DISJUNCTION", result, element[3], "infix", "\\vee", "∨", 4, "left");
      }, l);
    }

EqualPredicate
  = t1:Term _ i:EQUALS _ t2:Term {
      return createPredicate(i, 2, [t1, t2], "=");
  }

Predicate
  = i:Identifier _ OPEN _ args:TermList _ CLOSE {
      return createPredicate(i, args.length, args, i);
  }

Negation
  = NEG _ f:SimpleFormula {
      return createUnary("Negation", f, "prefix", "\\neg", "¬", 5);
  }

SimpleFormula
  = Quantifier
  / Predicate
  / EqualPredicate
  / Negation
  / OPEN _ f:Formula _ CLOSE { return f; }

Term
  = Function
  / Variable
  / Set
  / Tuple

Function
  = i:Variable _ OPEN _ args:TermList _ CLOSE {
      return createFunction(i, args.length, args, i);
  }

Set
  = LBRACE _ args:TermList _ RBRACE {
      return createSet(args.length, args);
  }

TermList
  = head:Term tail:(_ COMMA _ Term)* {
      return [head].concat(tail.map(e => e[3]));
  }

Tuple
  = OPEN _ args:TermList _ CLOSE {
      return createTuple(args.length, args);
  }