{
  // Helper functions for creating AST nodes
  function createQuantifier(variable, formula, name) {
    return { type: "Quantifier", variable: variable, formula: formula, name: name };
  }

  function createLogicalUnary(formula, name) {
    return { type: "LogicalUnary", formula: formula, name: name };
  }

  function createLogicalBinary(left, right, name) {
    return { type: "LogicalBinary", left: left, right: right, name: name };
  }

  function createApplication(symbol, count, args) {
    return { type: "Application", symbol: symbol, arguments: args.slice(0, count) };
  }

  function createVariable(name) {
    return { type: "Variable", name: name, metavar: false, bound: false };
  }

  function createTuple(count, terms) {
    return { type: "Tuple", elements: terms.slice(0, count) };
  }

  // Binds a variable in a formula
  function bind_var(variable, formula) {
    function bind(node) {
      if (node.type === "Variable" && node.name === variable.name) {
        node.bound = true;
      } else if (node.type === "Application") {
        node.arguments.forEach(bind);
      } else if (node.type === "Tuple") {
        node.elements.forEach(bind);
      } else if (node.type === "Quantifier") {
        bind(node.formula);
      } else if (node.type === "LogicalUnary") {
        bind(node.formula);
      } else if (node.type === "LogicalBinary") {
        bind(node.left);
        bind(node.right);
      }
    }
    bind(formula);
  }
}

Start
  = _ formula:Formula _ { return formula; }

// Lexical rules
_
  = [ \t]*

EOL
  = '\n' / '\r' / '\r\n'

Variable
  = [a-zA-Z] [a-zA-Z0-9]* { return createVariable(text()); }

QuantifierOp
  = FORALL
  / EXISTS

NEG = "\\neg" { return 'neg' }
WEDGE = "\\wedge" { return 'wedge' }
VEE = "\\vee" { return 'vee' }
IMPLIES = "\\implies" { return 'implies' }
IFF = "\\iff" { return 'iff' }
FORALL = "\\forall" { return 'forall'; }
EXISTS = "\\exists" { return 'exists'; }
EQUALS = '=' { return createVariable('equals'); }
OPEN = '('
CLOSE = ')'
COMMA = ','
LBRACE = '{'
RBRACE = '}'

// Main rules
Formula
  = Quantifier
  / IffFormula
  / Predicate

Quantifier
  = op:QuantifierOp _ v:Variable _ f:SimpleFormula {
      bind_var(v, f);
      return createQuantifier(v, f, op);
  }

IffFormula
  = l:ImpliesFormula _ IFF _ r:IffFormula {
      return createLogicalBinary(l, r, "iff");
  }
  / ImpliesFormula

ImpliesFormula
  = l:AndFormula _ IMPLIES _ r:ImpliesFormula {
      return createLogicalBinary(l, r, "implies");
  }
  / AndFormula

AndFormula
  = l:OrFormula tail:(_ WEDGE _ r:OrFormula)* {
      return tail.reduce((result, element) => {
        return createLogicalBinary(result, element[3], "wedge");
      }, l);
    }

OrFormula
  = l:SimpleFormula tail:(_ VEE _ r:SimpleFormula)* {
      return tail.reduce((result, element) => {
        return createLogicalBinary(result, element[3], "vee");
      }, l);
    }

EqualPredicate
  = t1:Term _ i:EQUALS _ t2:Term {
      return createApplication(i, 2, [t1, t2]);
  }

Predicate
  = f:Application

Negation
  = NEG _ f:SimpleFormula {
      return createLogicalUnary(f, "neg");
  }

Metavariable
  = v:Variable { v.metavar = true; return v; }
  
SimpleFormula
  = Quantifier
  / EqualPredicate
  / Predicate
  / Negation
  / Metavariable
  / OPEN _ f:Formula _ CLOSE { return f; }

Term
  = Application
  / Variable
  / Tuple

Application
  = i:Variable _ OPEN _ args:TermList _ CLOSE {
      return createApplication(i, args.length, args);
  }

TermList
  = head:Term tail:(_ COMMA _ Term)* {
      return [head].concat(tail.map(e => e[3]));
  }

Tuple
  = OPEN _ args:TermList _ CLOSE {
      return createTuple(args.length, args);
  }
