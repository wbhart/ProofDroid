<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Proof Droid -- v0.1</title>
    <style type="text/css">
        H1.header { text-align: center }
        .output-heading { font-size: 1.2em; }
        .mathjax-container { font-size: 0.8em; }
        #fileList {
            list-style-type: none;
        }
    </style>
    <!-- Include MathJax -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1 class="header">Proof Droid -- ver 0.1</h1>
    <textarea id="inputField" placeholder="Enter text to parse" rows="15" cols="72"></textarea><img src="droid.png" width="280ex">
    <h2 class="output-heading">String Representations</h2>
    <p><b>Latex:</b> <pre id="str-repr"></pre></p>
    <p><b>Unicode:</b> <pre id="str-unicode"></pre></p>
    <p><b>Polish:</b> <pre id="str-polish"></pre></p>
    <p><b>MathJax:</b></p>
    <div id="mathjax-container" class="mathjax-container"></div>
    <p id="status">Edit Mode: Type your formulas and click outside the text box to save.</p>

    <h1>List of JSON Files</h1>
    <ul id="fileList"></ul>

    <script src="list_files.js"></script>

    <script type="module">
        import { parse } from './parser.js';
        import { str_repr, str_unicode, str_polish, str_mathjax } from './strings.js';
        import { modus_ponens } from './moves.js';
        import { initializeContext, getContext, updateContext } from './context.js';
        import { getCurrentLine, getCaretPosition } from './interface_helper.js';

        let state = 'edit';
        let selectedLine1 = null;
        let context = initializeContext();

        const inputField = document.getElementById('inputField');
        const statusField = document.getElementById('status');
        const strReprField = document.getElementById('str-repr');
        const strUnicodeField = document.getElementById('str-unicode');
        const strPolishField = document.getElementById('str-polish');
        const mathjaxContainer = document.getElementById('mathjax-container');

        function updateStatus(message) {
            statusField.innerText = message;
        }

        function updateTextAreaWithRepr() {
            inputField.value = context.formulas.map(f => str_repr(f)).join('\n');
        }

        function updateTextAreaWithUnicode() {
            inputField.value = context.formulas.map(f => str_unicode(f)).join('\n');
        }

        function updateMathJax() {
            mathjaxContainer.innerHTML = context.formulas.map(f => `$${str_mathjax(f)}$`).join('<br>');
            MathJax.typesetPromise();
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'e' && state === 'initial') {
                state = 'edit';
                inputField.disabled = false;
                inputField.placeholder = 'Enter text to parse';
                updateStatus('Edit Mode: Type your formulas and click outside the text box to save.');
                updateTextAreaWithRepr();
            } else if (event.key === 'm' && state === 'initial' && context.formulas.length > 0) {
                state = 'manual';
                updateStatus('Manual Mode: Press \'p\' to perform Modus Ponens.');
            } else if (event.key === 'p' && state === 'manual') {
                state = 'modus_ponens';
                inputField.disabled = false;
                updateStatus('Modus Ponens Mode: Click on an implication, then an antecedent.');
            } else if (event.key === 'Escape') {
                state = 'initial';
                selectedLine1 = null;
                inputField.disabled = true;
                updateTextAreaWithUnicode();
                updateMathJax();
                updateStatus('Press \'e\' to enter edit mode. Press \'m\' for manual mode.');
            }
        });

        inputField.addEventListener('blur', () => {
            if (state === 'edit') {
                const lines = inputField.value.split('\n');
                const newContext = initializeContext();
                newContext.formulas = [];

                for (let i = 0; i < lines.length; i++) {
                    try {
                        const formula = parse(lines[i]);
                        newContext.formulas.push(formula);
                    } catch (e) {
                        if (e.name === 'SyntaxError') {
                            updateStatus(`Syntax Error on line ${i + 1}: ${e.message}`);
                            return;
                        }
                    }
                }

                updateContext(newContext);
                context = newContext;
                updateTextAreaWithUnicode();
                updateMathJax();
                state = 'initial';
                inputField.disabled = true;
                updateStatus('Press \'e\' to enter edit mode. Press \'m\' for manual mode.');
            }
        });

        inputField.addEventListener('input', (event) => {
            if (state !== 'edit') {
                event.preventDefault();
                return false;
            }

            const currentLine = getCurrentLine(inputField);

            try {
                const result = parse(currentLine);
                updateStatus('');
                strReprField.innerText = str_repr(result);
                strUnicodeField.innerText = str_unicode(result);
                strPolishField.innerText = str_polish(result);
                mathjaxContainer.innerHTML = `$${str_mathjax(result)}$`;
                MathJax.typesetPromise();
            } catch (e) {
                if (state === 'edit' && e.name === 'SyntaxError') {
                    updateStatus(`Syntax Error: ${e.message}`);
                    strReprField.innerText = '';
                    strUnicodeField.innerText = '';
                    strPolishField.innerText = '';
                    mathjaxContainer.innerHTML = '';
                } else {
                    throw e; // Re-throw the exception for other types of errors
                }
            }
        });

        inputField.addEventListener('click', (event) => {
            if (state === 'modus_ponens') {
                const lines = inputField.value.split('\n');
                const clickedLine = getCurrentLine(inputField);
                const selectedIndex = lines.indexOf(clickedLine);

                if (selectedLine1 === null) {
                    const formula1 = context.formulas[selectedIndex];
                    if (formula1.type === 'LogicalBinary' && formula1.name === 'implies') {
                        selectedLine1 = selectedIndex;
                        updateStatus('Modus Ponens Mode: Click on an antecedent.');
                    } else {
                        updateStatus('Error: Selected line is not an implication.');
                    }
                } else {
                    const formula1 = context.formulas[selectedLine1];
                    const formula2 = context.formulas[selectedIndex];

                    const result = modus_ponens(formula1, formula2);
                    if (result) {
                        context.formulas.push(result);
                        updateTextAreaWithUnicode();
                        updateMathJax();
                        updateStatus('Modus Ponens applied successfully.');
                    } else {
                        updateStatus('Modus Ponens failed.');
                    }

                    updateContext(context);
                    selectedLine1 = null;
                    state = 'initial';
                    inputField.disabled = true;
                }
            }
        });

        // Start the program in edit mode
        inputField.disabled = false;
        updateStatus('Edit Mode: Type your formulas and click outside the text box to save.');
    </script>
</body>
</html>
