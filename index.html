<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Proof Droid -- v0.1</title>
    <style type="text/css">
        H1.header { text-align: center }
        .output-heading { font-size: 1.2em; }
        .mathjax-container { font-size: 0.8em; }
    </style>
    <!-- Include MathJax -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1 class="header">Proof Droid -- ver 0.1</h1>
    <textarea id="inputField" placeholder="Enter text to parse" rows="15" cols="72"></textarea>
    <img src="droid.png" width="280ex">
    <select id="systemSelector" style="display:none;">
        <option value="" disabled selected>Select a system</option>
    </select>
    <h2 class="output-heading">String Representations</h2>
    <p><b>Latex:</b> <pre id="str-repr"></pre></p>
    <p><b>Unicode:</b> <pre id="str-unicode"></pre></p>
    <p><b>Polish:</b> <pre id="str-polish"></pre></p>
    <p><b>MathJax:</b></p>
    <div id="mathjax-container" class="mathjax-container"></div>
    <p id="status">Press 'e' to enter edit mode. Press 'm' for manual mode. Press 'l' to list systems.</p>

    <script type="module">
        import { parse } from './parser.js';
        import { str_repr, str_unicode, str_polish, str_mathjax } from './strings.js';
        import { modus_ponens } from './moves.js';
        import { initializeContext, getContext, updateContext } from './context.js';
        import { getCurrentLine, getCaretPosition } from './interface_helper.js';
        import { listFiles } from './list_files.js';

        let state = 'initial';
        let selectedLine1 = null;
        let context = initializeContext();

        const inputField = document.getElementById('inputField');
        const statusField = document.getElementById('status');
        const strReprField = document.getElementById('str-repr');
        const strUnicodeField = document.getElementById('str-unicode');
        const strPolishField = document.getElementById('str-polish');
        const mathjaxContainer = document.getElementById('mathjax-container');
        const systemSelector = document.getElementById('systemSelector');

        function updateStatus(message) {
            statusField.innerText = message;
        }

        function updateTextAreaWithRepr() {
            inputField.value = context.formulas.map(f => str_repr(f)).join('\n');
        }

        function updateTextAreaWithUnicode() {
            inputField.value = context.formulas.map(f => str_unicode(f)).join('\n');
        }

        function updateMathJax(formula) {
            if (formula) {
                mathjaxContainer.innerHTML = `$${str_mathjax(formula)}$`;
                MathJax.typesetPromise();
            } else {
                mathjaxContainer.innerHTML = '';
            }
        }

        function fetchSystemData(fileName) {
            return fetch(`systems/${fileName}`)
                .then(response => response.json());
        }

        async function loadSystemSelector() {
            state = 'list_systems';
            updateStatus('List Systems Mode: Loading systems...');
            try {
                const files = await listFiles('systems');
                const systems = [];
                for (const file of files) {
                    const data = await fetchSystemData(file);
                    systems.push({ name: data.system, file });
                }
                systemSelector.innerHTML = '<option value="" disabled selected>Select a system</option>' + 
                                            systems.map(system => `<option value="${system.file}">${system.name}</option>`).join('');
                systemSelector.style.display = 'block';
                updateStatus('Select a system from the dropdown list.');
            } catch (error) {
                updateStatus(`Error loading systems: ${error.message}`);
                state = 'initial';
                displayInitialPrompt();
            }
        }

        function displayInitialPrompt() {
            updateStatus('Press \'e\' to enter edit mode. Press \'m\' for manual mode. Press \'l\' to list systems.');
        }

        function displayManualPrompt() {
            updateStatus('Manual Mode: Press \'p\' to perform Modus Ponens. Press ESC to exit manual mode.');
        }

        function waitForEnter(callback) {
            function handler(event) {
                if (event.key === 'Enter') {
                    document.removeEventListener('keydown', handler);
                    callback();
                }
            }
            document.addEventListener('keydown', handler);
        }

        document.addEventListener('keydown', async (event) => {
            if (event.key === 'e' && state === 'initial') {
                state = 'edit';
                inputField.disabled = false;
                inputField.placeholder = 'Enter text to parse';
                updateStatus('Edit Mode: Type your formulas and click outside the text box to save.');
                updateTextAreaWithRepr();
            } else if (event.key === 'm' && state === 'initial' && context.formulas.length > 0) {
                state = 'manual';
                displayManualPrompt();
            } else if (event.key === 'p' && state === 'manual') {
                state = 'modus_ponens';
                inputField.disabled = false;
                updateStatus('Modus Ponens Mode: Click on an implication, then an antecedent.');
            } else if (event.key === 'l' && state === 'initial') {
                await loadSystemSelector();
            } else if (event.key === 'Escape') {
                state = 'initial';
                selectedLine1 = null;
                inputField.disabled = true;
                systemSelector.style.display = 'none';
                updateTextAreaWithUnicode();
                updateMathJax();
                displayInitialPrompt();
            }
        });

        inputField.addEventListener('blur', () => {
            if (state === 'edit') {
                const lines = inputField.value.split('\n');
                const newContext = initializeContext();
                newContext.formulas = [];

                for (let i = 0; i < lines.length; i++) {
                    try {
                        const formula = parse(lines[i]);
                        newContext.formulas.push(formula);
                    } catch (e) {
                        if (e.name === 'SyntaxError') {
                            updateStatus(`Syntax Error on line ${i + 1}: ${e.message}`);
                            return;
                        }
                    }
                }

                updateContext(newContext);
                context = newContext;
                updateTextAreaWithUnicode();
                updateMathJax();
                state = 'initial';
                inputField.disabled = true;
                displayInitialPrompt();
            }
        });

        inputField.addEventListener('input', (event) => {
            if (state !== 'edit') {
                event.preventDefault();
                return false;
            }

            const currentLine = getCurrentLine(inputField);

            try {
                const result = parse(currentLine);
                updateStatus('');
                strReprField.innerText = str_repr(result);
                strUnicodeField.innerText = str_unicode(result);
                strPolishField.innerText = str_polish(result);
                updateMathJax(result);
            } catch (e) {
                if (state === 'edit' && e.name === 'SyntaxError') {
                    updateStatus(`Syntax Error: ${e.message}`);
                    strReprField.innerText = '';
                    strUnicodeField.innerText = '';
                    strPolishField.innerText = '';
                    mathjaxContainer.innerHTML = '';
                } else {
                    throw e; // Re-throw the exception for other types of errors
                }
            }
        });

        inputField.addEventListener('click', (event) => {
            if (state === 'modus_ponens') {
                const lines = inputField.value.split('\n');
                const clickedLine = getCurrentLine(inputField);
                const selectedIndex = lines.indexOf(clickedLine);

                if (selectedLine1 === null) {
                    const formula1 = context.formulas[selectedIndex];
                    if (formula1.type === 'LogicalBinary' && formula1.name === 'implies') {
                        selectedLine1 = selectedIndex;
                        updateStatus('Modus Ponens Mode: Click on an antecedent.');
                    } else {
                        updateStatus('Error: Selected line is not an implication. Press Enter to continue.');
                        waitForEnter(() => {
                            selectedLine1 = null;
                            state = 'manual';
                            inputField.disabled = true;
                            displayManualPrompt();
                        });
                    }
                } else {
                    const formula1 = context.formulas[selectedLine1];
                    const formula2 = context.formulas[selectedIndex];

                    const result = modus_ponens(formula1, formula2);
                    if (result) {
                        context.formulas.push(result);
                        updateTextAreaWithUnicode();
                        updateMathJax();
                        displayManualPrompt();
                    } else {
                        updateStatus('Modus Ponens failed. Press Enter to continue.');
                        waitForEnter(() => {
                            selectedLine1 = null;
                            state = 'manual';
                            inputField.disabled = true;
                            displayManualPrompt();
                        });
                    }

                    updateContext(context);
                }
            }
        });

        systemSelector.addEventListener('change', async () => {
            const selectedFile = systemSelector.value;
            try {
                const data = await fetchSystemData(selectedFile);
                const newContext = initializeContext();
                newContext.formulas = [];
                for (const axiom of data.axioms) {
                    newContext.formulas.push(parse(axiom));
                }
                updateContext(newContext);
                context = newContext;
                updateTextAreaWithUnicode();
                updateMathJax();
                state = 'initial';
                systemSelector.style.display = 'none';
                displayInitialPrompt();
            } catch (error) {
                updateStatus(`Error loading system: ${error.message}`);
            }
        });

        // Start the program in initial mode
        inputField.disabled = true;
        displayInitialPrompt();
    </script>
</body>
</html>
