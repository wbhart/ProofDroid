<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Proof Droid -- v0.1</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <!-- Include MathJax -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1 class="header">Proof Droid -- ver 0.1</h1>
    <div class="content">
        <div class="left-column">
            <div id="inputFieldHypotheses" contenteditable="true" class="editable-div"></div>
            <div id="inputFieldTargets" contenteditable="true" class="editable-div"></div>
            <select id="systemSelector" style="display:none;"></select>
        </div>
        <div class="middle-column">
            <img src="droid.png" alt="Droid Image">
        </div>
        <div class="right-column" id="right-column">
            <h2 id="right-column-title">Welcome</h2>
            <div id="right-column-content" class="scrollable-content">
                <p>Proof Droid is a program for proving theorems in various formal systems.</p>
            </div>
        </div>
    </div>
    <div class="status-bar" id="status">Press 'e' to enter edit mode. Press 'm' for manual mode. Press 'l' to list systems.</div>

    <script type="module">
        import { parse } from './parser.js';
        import { str_repr, str_unicode, str_mathjax } from './strings.js';
        import { modus_ponens, specification } from './moves.js';
        import { initializeContext, updateContext } from './context.js';
        import { getCaretPosition } from './interface_helper.js';
        import { listFiles } from './list_files.js';

        let state = 'initial';
        let selectedLine1 = null;
        let context = initializeContext();

        const inputFieldHypotheses = document.getElementById('inputFieldHypotheses');
        const inputFieldTargets = document.getElementById('inputFieldTargets');
        const statusField = document.getElementById('status');
        const rightColumnTitle = document.getElementById('right-column-title');
        const rightColumnContent = document.getElementById('right-column-content');
        const systemSelector = document.getElementById('systemSelector');

        function updateStatus(message) {
            statusField.innerText = message;
        }

        function updateDivWithRepr() {
            inputFieldHypotheses.innerHTML = ''; // Clear hypotheses area
            inputFieldTargets.innerHTML = ''; // Clear targets area

            const hypothesisLines = getHypothesisLines();
            const targetLines = getTargetLines();

            hypothesisLines.forEach((line) => {
                const lineDiv = document.createElement('div');
                lineDiv.textContent = str_repr(line.formula);
                inputFieldHypotheses.appendChild(lineDiv);
            });

            targetLines.forEach((line) => {
                const lineDiv = document.createElement('div');
                lineDiv.textContent = str_repr(line.formula);
                inputFieldTargets.appendChild(lineDiv);
            });
        }

        function updateDivWithUnicode() {
            inputFieldHypotheses.innerHTML = ''; // Clear hypotheses area
            inputFieldTargets.innerHTML = ''; // Clear targets area

            const hypothesisLines = getHypothesisLines();
            const targetLines = getTargetLines();

            hypothesisLines.forEach((line) => {
                const lineDiv = document.createElement('div');
                lineDiv.style.display = 'flex';
                lineDiv.style.justifyContent = 'space-between';

                const formulaSpan = document.createElement('span');
                formulaSpan.textContent = str_unicode(line.formula);

                const reasonSpan = document.createElement('span');
                reasonSpan.textContent = `${line.justification[0]}${line.justification[1].length > 0 ? `[${line.justification[1].join(', ')}]` : ''}`;
                reasonSpan.style.whiteSpace = 'nowrap';

                lineDiv.appendChild(formulaSpan);
                lineDiv.appendChild(reasonSpan);

                inputFieldHypotheses.appendChild(lineDiv);
            });

            targetLines.forEach((line) => {
                const lineDiv = document.createElement('div');
                lineDiv.style.display = 'flex';
                lineDiv.style.justifyContent = 'space-between';

                const formulaSpan = document.createElement('span');
                formulaSpan.textContent = str_unicode(line.formula);

                const reasonSpan = document.createElement('span');
                reasonSpan.textContent = `${line.justification[0]}${line.justification[1].length > 0 ? `[${line.justification[1].join(', ')}]` : ''}`;
                reasonSpan.style.whiteSpace = 'nowrap';

                lineDiv.appendChild(formulaSpan);
                lineDiv.appendChild(reasonSpan);

                inputFieldTargets.appendChild(lineDiv);
            });
        }

        function updateMathJax(formula) {
            if (formula) {
                updateStatus(`Successfully parsed: $${str_mathjax(formula)}$`);
                MathJax.typesetPromise();
            }
        }

        function fetchSystemData(fileName) {
            return fetch(`systems/${fileName}`)
                .then(response => response.json());
        }

        async function loadSystemSelector() {
            state = 'list_systems';
            updateStatus('List Systems Mode: Loading systems...');
            try {
                const files = await listFiles('systems');
                const systems = [];
                for (const file of files) {
                    const data = await fetchSystemData(file);
                    systems.push({ name: data.system, file });
                }
                systemSelector.innerHTML = '<option value="" disabled selected>Select a system</option>' + 
                                            systems.map(system => `<option value="${system.file}">${system.name}</option>`).join('');
                systemSelector.style.display = 'block';
                updateStatus('Select a system from the dropdown list.');
            } catch (error) {
                updateStatus(`Error loading systems: ${error.message}`);
                state = 'initial';
                displayInitialPrompt();
            }
        }

        function displayInitialPrompt() {
            updateStatus('Press \'e\' to enter edit mode. Press \'m\' for manual mode. Press \'l\' to list systems.');
            rightColumnTitle.innerText = 'Welcome';
            rightColumnContent.innerHTML = '<p>Proof Droid is a program for proving theorems in various formal systems.</p>';
        }

        function displayEditModeHelp() {
            rightColumnTitle.innerText = 'Edit Mode';
            rightColumnContent.innerHTML = `
                <p>In edit mode, you can use the following LaTeX input symbols:</p>
                <ul>
                    <li>\\forall: ∀ (for all)</li>
                    <li>\\exists: ∃ (exists)</li>
                    <li>\\wedge: ∧ (and)</li>
                    <li>\\vee: ∨ (or)</li>
                    <li>\\uparrow: ↑ (Sheffer stroke)</li>
                    <li>\\neg: ¬ (not)</li>
                    <li>\\top: ⊤ (true)</li>
                    <li>\\bot: ⊥ (false)</li>
                    <li>\\implies: → (implies)</li>
                    <li>\\iff: ↔ (iff)</li>
                    <li>=: = (equals)</li>
                    <li>\\emptyset: ∅ (empty set)</li>
                    <li>\\setminus: \\ (set difference)</li>
                    <li>\\cap: ∩ (intersection)</li>
                    <li>\\cup: ∪ (union)</li>
                </ul>
                <p><b>Terms:</b></p>
                <ul>
                    <li><b>Variable:</b> Single letter identifiers (e.g., x, y, z)</li>
                    <li><b>Function:</b> f(t1, t2, ..., tn), where t1, ..., tn are terms</li>
                    <li><b>Tuple:</b> (t1, t2, ..., tn) where t1, ..., tn are terms</li>
                    <li><b>Set:</b> {t1, t2, ..., tn} where t1, ..., tn are terms</li>
                </ul>
                <p><b>Formulas:</b></p>
                <ul>
                    <li><b>Equals:</b> t1 = t2 for terms t1 and t2</li>
                    <li><b>Logical Connectives:</b> ¬F, F ∧ G, F ∨ G, F → G, F ↔ G for formulas F and G</li>
                    <li><b>Quantifiers:</b> ∀ x (F), ∃ x (F) for variable x and formula F</li>
                    <li><b>Metavariable:</b> Single letter identifiers (e.g. p, q, r) at the formula level</li>
                </ul>
                <p>Press ESC to exit edit mode.</p>
            `;
        }

        function displayManualPrompt() {
            updateStatus('Manual Mode: Press \'p\' to perform Modus Ponens. Press ESC to exit manual mode.');
            rightColumnTitle.innerText = 'Manual Mode';
            rightColumnContent.innerHTML = '<p>In manual mode, you can perform Modus Ponens by pressing \'p\' and then selecting the implication and antecedent lines. Press ESC to exit manual mode.</p>';
        }

        function waitForEnter(callback) {
            function handler(event) {
                if (event.key === 'Enter') {
                    document.removeEventListener('keydown', handler);
                    callback();
                }
            }
            document.addEventListener('keydown', handler);
        }

        function getHypothesisLines() {
            return context.lines.filter(line => !line.target);
        }

        function getTargetLines() {
            return context.lines.filter(line => line.target);
        }

        function addLineToContext(line, isTarget = false, assumptions = [], justification = isTarget ? ['Tar', []] : ['Hyp', []]) {
            context.lines.push({
                formula: line,
                target: isTarget,
                assumptions: assumptions,
                proved: !isTarget,
                justification: justification
            });
        }


        inputFieldHypotheses.addEventListener('input', handleHypothesisInput);
        inputFieldTargets.addEventListener('input', handleTargetInput);

        function handleHypothesisInput(event) {
            const lines = inputFieldHypotheses.innerText.split('\n');
            const currentLineIndex = getCaretPosition(inputFieldHypotheses).line;
            const currentLine = lines[currentLineIndex]?.trim() || '';

            if (currentLine === '') {
                updateStatus('');
                return;
            }

            try {
                const result = parse(currentLine);
                updateStatus(`Parsed successfully: ${str_repr(result)}`);
                updateMathJax(result);

                // Add the line as a hypothesis
                addLineToContext(result, false);
            } catch (e) {
                if (e.name === 'SyntaxError') {
                    updateStatus(`Syntax Error: ${e.message}`);
                } else {
                    throw e; // Re-throw the exception for other types of errors
                }
            }
        }

        function handleTargetInput(event) {
            const lines = inputFieldTargets.innerText.split('\n');
            const currentLineIndex = getCaretPosition(inputFieldTargets).line;

            if (currentLineIndex > 0) {
                // Prevent editing of lines other than the first one
                updateDivWithRepr(); // Reset the content to remove any unwanted changes
                return;
            }

            const currentLine = lines[currentLineIndex]?.trim() || '';

            if (currentLine === '') {
                updateStatus('');
                return;
            }

            try {
                const result = parse(currentLine);
                updateStatus(`Parsed successfully: ${str_repr(result)}`);
                updateMathJax(result);

                // Add or update the line as a target
                if (getTargetLines().length > 0) {
                    // Update the existing target line
                    const targetLine = getTargetLines()[0];
                    targetLine.formula = result;
                } else {
                    // Add a new target line
                    addLineToContext(result, true);
                }
            } catch (e) {
                if (e.name === 'SyntaxError') {
                    updateStatus(`Syntax Error: ${e.message}`);
                } else {
                    throw e; // Re-throw the exception for other types of errors
                }
            }
        }

        // Function to apply specification to all formulas in the context
        function specifyContextFormulas() {
            context.lines.forEach(line => {
                // Apply the specification function only to formulas that are not already targets
                if (!line.target) {
                    line.formula = specification(line.formula);
                }
            });

            // After modifying the formulas, update the UI
            updateContext(context);
            updateDivWithUnicode();  // Update the view to show the updated formulas
        }
        
        document.addEventListener('keydown', async (event) => {
            if (state === 'initial') {
                if (event.key === 'e') {
                    state = 'edit';
                    inputFieldHypotheses.contentEditable = true;
                    inputFieldTargets.contentEditable = true;
                    updateStatus('Edit Mode: Type your formulas and click outside the text box to save.');
                    updateDivWithRepr(); // Enter edit mode (repr mode)
                    displayEditModeHelp();
                } else if (event.key === 'm' && context.lines.length > 0) {
                    state = 'manual';
                    displayManualPrompt();

                    // Apply specification to all formulas in the context
                    specifyContextFormulas();  // <-- Call the function here

                } else if (event.key === 'l') {
                    await loadSystemSelector();  // Load the system selector when 'l' is pressed
                }
            } else if (state === 'manual' || state === 'modus_ponens') {
                if (event.key === 'p' && state === 'manual') {
                    state = 'modus_ponens';
                    selectedLine1 = null;
                    inputFieldHypotheses.contentEditable = false;
                    inputFieldTargets.contentEditable = false;
                    updateStatus('Modus Ponens Mode: Click on an implication, then an antecedent.');
                } else if (event.key === 'Escape') {
                    // Handle escape in both manual and modus ponens modes
                    state = 'initial';
                    selectedLine1 = null;
                    inputFieldHypotheses.contentEditable = false;
                    inputFieldTargets.contentEditable = false;
                    updateDivWithUnicode(); // Exit any mode, update to unicode view with reasons
                    displayInitialPrompt();
                }
            } else if (event.key === 'Escape' && state === 'edit') {
                state = 'initial';
                selectedLine1 = null;
                inputFieldHypotheses.contentEditable = false;
                inputFieldTargets.contentEditable = false;
                updateDivWithUnicode(); // Exit edit mode, update to unicode view with reasons
                displayInitialPrompt();
            }
        });

        inputFieldHypotheses.addEventListener('blur', () => {
            if (state === 'edit') {
                const lines = inputFieldHypotheses.innerText.split('\n');

                // Clear out the current hypothesis lines in the context
                context.lines = context.lines.filter(line => line.target);

                for (let i = 0; i < lines.length; i++) {
                    const trimmedLine = lines[i].trim();
                    if (trimmedLine === '') {
                        continue; // Skip empty lines
                    }
                    try {
                        const formula = parse(trimmedLine);
                        addLineToContext(formula, false);
                        updateMathJax(formula);
                    } catch (e) {
                        if (e.name === 'SyntaxError') {
                            updateStatus(`Syntax Error on line ${i + 1}: ${e.message}`);
                            return;
                        }
                    }
                }

                // Update the context and display the results
                updateContext(context);
                updateDivWithUnicode(); // Exit edit mode, update to unicode view with reasons
                state = 'initial';
                inputFieldHypotheses.contentEditable = false;
                inputFieldTargets.contentEditable = false;
                displayInitialPrompt();
            }
        });

        inputFieldTargets.addEventListener('blur', () => {
            if (state === 'edit') {
                const lines = inputFieldTargets.innerText.split('\n');
                const trimmedLine = lines[0].trim(); // Only first line is editable

                if (trimmedLine === '') {
                    updateStatus('');
                    return;
                }

                try {
                    const formula = parse(trimmedLine);
                    if (getTargetLines().length > 0) {
                        // Update the existing target line
                        const targetLine = getTargetLines()[0];
                        targetLine.formula = formula;
                    } else {
                        // Add a new target line
                        addLineToContext(formula, true);
                    }
                    updateMathJax(formula);
                } catch (e) {
                    if (e.name === 'SyntaxError') {
                        updateStatus(`Syntax Error on target line: ${e.message}`);
                        return;
                    }
                }

                updateDivWithUnicode(); // Exit edit mode, update to unicode view with reasons
                state = 'initial';
                inputFieldTargets.contentEditable = false;
                inputFieldHypotheses.contentEditable = false;
                displayInitialPrompt();
            }
        });

        inputFieldHypotheses.addEventListener('click', (event) => {
            if (state === 'modus_ponens') {
                const target = event.target;
                const lineDiv = target.closest('div');
                if (!lineDiv) {
                    updateStatus('Error: Could not find the clicked line. Please try again.');
                    return;
                }

                const lineIndex = Array.from(inputFieldHypotheses.children).indexOf(lineDiv);
                if (lineIndex === -1 || lineIndex >= getHypothesisLines().length) {
                    updateStatus('Error: Could not find the clicked line. Please try again.');
                    return;
                }

                const clickedLine = getHypothesisLines()[lineIndex];
                if (!clickedLine) {
                    updateStatus('Error: Could not find the clicked line. Please try again.');
                    return;
                }

                if (selectedLine1 === null) {
                    const formula1 = clickedLine.formula;
                    if (formula1.type === 'LogicalBinary' && formula1.name === 'implies') {
                        selectedLine1 = lineIndex;
                        updateStatus('Modus Ponens Mode: Click on an antecedent.');
                    } else {
                        updateStatus('Error: Selected line is not an implication. Press Enter to continue.');
                        waitForEnter(() => {
                            selectedLine1 = null;
                            state = 'manual';
                            inputFieldHypotheses.contentEditable = true;
                            displayManualPrompt();
                        });
                    }
                } else {
                    const formula1 = getHypothesisLines()[selectedLine1].formula;
                    const formula2 = clickedLine.formula;

                    const result = modus_ponens(formula1, formula2);
                    if (result) {
                        const justification = ['MP', [selectedLine1 + 1, lineIndex + 1]]; // Use 1-based indexing
                        addLineToContext(result, false, [selectedLine1, lineIndex], justification);
                        updateDivWithUnicode(); // Update view to show the new line with reasons
                        state = 'manual';
                        displayManualPrompt();
                    } else {
                        updateStatus('Modus Ponens failed. Press Enter to continue.');
                        waitForEnter(() => {
                            selectedLine1 = null;
                            state = 'manual';
                            inputFieldHypotheses.contentEditable = true;
                            displayManualPrompt();
                        });
                    }

                    updateContext(context);
                    inputFieldHypotheses.contentEditable = true;
                }
            }
        });

        systemSelector.addEventListener('change', async () => {
            const selectedFile = systemSelector.value;
            try {
                const data = await fetchSystemData(selectedFile);
                const newContext = initializeContext();

                if (data && Array.isArray(data.axioms)) {
                    for (const axiom of data.axioms) {
                        newContext.lines.push({
                            formula: parse(axiom),
                            target: false,
                            assumptions: [],
                            proved: true,
                            justification: ['Hyp', []]
                        });
                    }
                } else {
                    throw new Error('System data is not correctly formatted');
                }

                updateContext(newContext);
                context = newContext;
                updateDivWithUnicode(); // Update view after loading system
                state = 'initial';
                systemSelector.style.display = 'none';
                displayInitialPrompt();
            } catch (error) {
                updateStatus(`Error loading system: ${error.message}`);
            }
        });

        // Start the program in initial mode
        inputFieldHypotheses.contentEditable = false;
        inputFieldTargets.contentEditable = false;
        displayInitialPrompt();
    </script>
</body>
</html>
